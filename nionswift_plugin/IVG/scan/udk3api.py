# CESYS Software License - Version 1.0 - January 1st, 2016
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The software must only be used to operate hardware manufactured by 
# CESYS GmbH, Herzogenaurach.
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# 
# Written by Thomas Hoppe <thomas.hoppe@cesys.com>, 2016

__author__  = "Thomas Hoppe"
__status__  = "production"
__version__ = "1.5.1"

import sys, platform
from ctypes import cdll, create_string_buffer, POINTER, byref
from ctypes import c_uint, c_int, c_char, c_char_p, c_void_p

def _getLibraryName():
    is64bit = sys.maxsize > 2**32
    baseName = "udk3-" + __version__
    if (platform.system() == "Windows"):
        return baseName + ("-x86_64.dll" if (is64bit) else "-x86.dll")
    if (platform.system() == "Linux"):
        return "lib" + baseName + ".so"
    if (platform.system() == "Darwin"):
        return "lib" + baseName + ".dylib"

def _buildFunction(call, args, result, errCheck = None):
    call.argtypes = args
    call.restype = result
    if (None != errCheck):
        call.errcheck = errCheck
    return call

def _isPython3():
    return sys.version_info[0] >= 3

def _createCharBuffer23(size):
    if (_isPython3()):
        return create_string_buffer(b'\000' * size)
    return create_string_buffer('\000' * size)

def _convertToString23(binaryString):
    if (_isPython3()):
        return binaryString.decode("utf-8")
    return binaryString

def _toString23(string):
    if (_isPython3()):
        return string.encode("utf-8")
    return string

def _checkError(result, func, arguments):
    if result != 0:
        error = _createCharBuffer23(CE_IF_BUFFER_SIZE)
        _CeGetLastErrorText(result, error)
        raise Exception(_convertToString23(error.value))

_library = cdll.LoadLibrary(_getLibraryName())

_CeGetLastErrorText = _buildFunction(_library.CeGetLastErrorText, [ c_int, POINTER(c_char) ], None)
_CeGetUdk3VersionString = _buildFunction(_library.CeGetUdk3VersionString, [], c_char_p)
_CeInit = _buildFunction(_library.CeInit, [], c_int, _checkError)
_CeInitEx = _buildFunction(_library.CeInitEx, [c_char_p], c_int, _checkError)
_CeEnumerate = _buildFunction(_library.CeEnumerate, [c_int, POINTER(c_int)], c_int, _checkError)
_CeEnumerateInfo = _buildFunction(_library.CeEnumerateInfo, [c_int, POINTER(c_char), POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)], c_int, _checkError)
_CeDeInit = _buildFunction(_library.CeDeInit, [], c_int, _checkError)
_CeSetLogLevel = _buildFunction(_library.CeSetLogLevel, [c_int], c_int, _checkError)
_CeOpen = _buildFunction(_library.CeOpen, [c_int, POINTER(c_int)], c_int, _checkError)
_CeClose = _buildFunction(_library.CeClose, [c_int], c_int, _checkError)
_CeReadRegister = _buildFunction(_library.CeReadRegister, [c_int, c_uint, POINTER(c_uint)], c_int, _checkError)
_CeWriteRegister = _buildFunction(_library.CeWriteRegister, [c_int, c_uint, c_uint], c_int, _checkError)
_CeReadBlock = _buildFunction(_library.CeReadBlock, [c_int, c_uint, c_void_p, c_int, c_int], c_int, _checkError)
_CeWriteBlock = _buildFunction(_library.CeWriteBlock, [c_int, c_uint, c_void_p, c_int, c_int], c_int, _checkError)
_CeWaitForInterrupt = _buildFunction(_library.CeWaitForInterrupt, [c_int, c_uint, POINTER(c_uint)], c_int, _checkError)
_CeEnableInterrupt = _buildFunction(_library.CeEnableInterrupt, [c_int], c_int, _checkError)
_CeResetFpga = _buildFunction(_library.CeResetFpga, [c_int], c_int, _checkError)
_CeProgramFpgaFromBin = _buildFunction(_library.CeProgramFpgaFromBin, [c_int, c_char_p], c_int, _checkError)
_CeProgramFpgaFromMemory = _buildFunction(_library.CeProgramFpgaFromMemory, [c_int, c_void_p, c_int], c_int, _checkError)
_CeProgramFpgaFromMemoryZ = _buildFunction(_library.CeProgramFpgaFromMemoryZ, [c_int, c_void_p, c_int], c_int, _checkError)
_CeSetTimeOut = _buildFunction(_library.CeSetTimeOut, [c_int, c_uint], c_int, _checkError)
_CeEnableBurst = _buildFunction(_library.CeEnableBurst, [c_int, c_uint], c_int, _checkError)
_CeSetUserId = _buildFunction(_library.CeSetUserId, [c_int, POINTER(c_char)], c_int, _checkError)
_CeGetUserId = _buildFunction(_library.CeGetUserId, [c_int, POINTER(c_char)], c_int, _checkError)
_CeGetSerialNumber = _buildFunction(_library.CeGetSerialNumber, [c_int, POINTER(c_char)], c_int, _checkError)
_CeGetFirmwareVersion = _buildFunction(_library.CeGetFirmwareVersion, [c_int, POINTER(c_char)], c_int, _checkError)
_CeGetDerivateInfo = _buildFunction(_library.CeGetDerivateInfo, [c_int, POINTER(c_char)], c_int, _checkError)
_CeGetDerivateId = _buildFunction(_library.CeGetDerivateId, [c_int, POINTER(c_uint)], c_int, _checkError)
_CeGetMaxTransferSize = _buildFunction(_library.CeGetMaxTransferSize, [c_int, POINTER(c_uint)], c_int, _checkError)
_CeInt1 = _buildFunction(_library.CeInt1, [c_int, c_int, c_int, c_int, c_int, c_void_p, c_int], c_int, _checkError)

CE_IF_BUFFER_SIZE = 16384

_enumRound = 0

# This enumeration lists all supported bus systems in UDK3.
# This type is returned from DeviceInfo.getBusType().
UNKNOWN_BUS = 0x00000000
PCI = 0x00000001
USB = 0x00000002

# List of available device types / groups used for enumeration. Used
# as input for enumerate() and returned by DeviceType.getDeviceType().
# INFO: NEW_DEVICE - All
UNKNOWN_TYPE = -1
ALL = 0x00000000
PCI_ALL = 0x00010000
PCIS3BASE = 0x00010001
DOB = 0x00010002
PCIEV4BASE = 0x00010003
RTC = 0x00010004
PSS = 0x00010005
DEFLECTOR = 0x00010006
LASERSONIC = 0x00010007
USB_ALL = 0x00020000
EFM01 = 0x00020001
USBV4F = 0x00020002
MISS2 = 0x00020003
CID = 0x00020004
USBS6 = 0x00020005
OP_MISS2 = 0x00020006
NANOUSB = 0x00020007
EFM02 = 0x00020008
EFM02B = 0x00020009
EFM03 = 0x0002000A

class DeviceInfo:
    """
    This type offers access to most of the device information. Some information
    is available after opening the device. An instance to this type can either
    be retrieved from EnumeratedDevice.getDeviceInfo() or Device.getDeviceInfo().
    """
    def __init__(self, name, bt, dt, vid, pid):
        self._handle = -1
        self._name= name
        self._bt = bt
        self._dt = dt
        self._vid = vid
        self._pid = pid

    def getName(self): return self._name
    def getBusType(self): return self._bt
    def getDeviceType(self): return self._dt
    def getVid(self): return self._vid
    def getPid(self): return self._pid

    def getMaxTransferSize(self):
        """
        Return maximum size of block which can be transfered with one transfer using the
        underlying protocol / bus. This is more for informational purposes, the API automatically splits
        larger packets into packets of this maximum size. -1 if not accessible or in case of error.
        """
        if self._handle == -1:
            return -1

        try:
            r = c_uint()
            _CeGetMaxTransferSize(self._handle, byref(r))
            return r.value
        except:
            return -1

    def setUserId(self, userId):
        """
        Set user ID. Writes the string to the device EEPROM.
        This ID is intended to differentiate multiple devices of the same type connected
        to one host. The ID can contain up to 63 ASCII characters.
        """
        if self._handle == -1:
            raise Exception("Device not opened.")

        buf = _createCharBuffer23(CE_IF_BUFFER_SIZE)
        usid = _toString23(userId)
        for i in range(len(usid)):
            buf[i] = usid[i]
        _CeSetUserId(self._handle, buf)

    def getUserId(self):
        """
        Return user ID from device EEPROM. See explanation in
        setUserId(). "" if not accessible or in case of error.
        """
        if self._handle == -1:
            return ""

        try:
            dinfo = _createCharBuffer23(CE_IF_BUFFER_SIZE)
            _CeGetUserId(self._handle, dinfo)
            return _convertToString23(dinfo.value)
        except:
            return ""

    def getSerialNumber(self):
        """
        Return serial number. Not supported by all device
        types / instances. "" if not accessible or in case of error.
        """
        if self._handle == -1:
            return ""

        try:
            dinfo = _createCharBuffer23(CE_IF_BUFFER_SIZE)
            _CeGetSerialNumber(self._handle, dinfo)
            return _convertToString23(dinfo.value)
        except:
            return ""

    def getFirmwareVersion(self):
        """
        Return firmware version of device. "" if not accessible or in case of error.
        """
        if self._handle == -1:
            return ""

        try:
            dinfo = _createCharBuffer23(CE_IF_BUFFER_SIZE)
            _CeGetFirmwareVersion(self._handle, dinfo)
            return _convertToString23(dinfo.value)
        except:
            return ""

    def getDerivateInfo(self):
        """
        Return derivate info string. "" if not accessible or in case of error.
        Some devices are available in different versions (different FPGA's, different peripherals).
        The returned string contains a textual information about the specific
        derivate. For programmatically differentiation, getDerivateId() is better suited.
        """
        if self._handle == -1:
            return ""

        try:
            dinfo = _createCharBuffer23(CE_IF_BUFFER_SIZE)
            _CeGetDerivateInfo(self._handle, dinfo)
            return _convertToString23(dinfo.value)
        except:
            return ""

    def getDerivateId(self):
        """
        Return derivate id. 0xffffffff if not accessible or in case of error.
        This ID is unique for every derivate of a specific device type.
        Existing derivates can be found in the documentation of the specific device type.
        """
        if self._handle == -1:
            return 0xffffffff

        try:
            r = c_uint()
            _CeGetDerivateId(self._handle, byref(r))
            return r.value
        except:
            return 0xffffffff

class Device:
    """
    This type offers functionality to communicate with a single device. Instances can be
    retrieved from EnumeratedDevice.open() and represent an opened connection to a device.
    """

    # This flag can be used in readBlock() and writeBlock() to specify transfer to a
    # constant address. The opposite and *default* behavior is incremental address.
    # Attention: For historical reasons, this flag is interpreted inverse inside the FPGA interface ->
    # "address auto increment" is 0 if FlagConstAddress is specified.
    FlagConstAddress = 0x00000001

    def __verify32Bit(self, value):
        """
        Check if value is in range 0 <= value <= 0xffffffff
        """
        if(value < 0 or value > 0xffffffff):
            raise AttributeError("Argument out of range (must be 32bit unsigned).")

    def __init__(self, info, handle):
        """
        Called by the API, do not call yourself.
        """
        self._info = info
        self._info._handle = handle
        self._handle = handle

    def close(self):
        """
        Free access to device. After this call the device is available in new enumerations and
        this instance of type Device can't be used anymore.
        """
        _CeClose(self._handle)

    def readRegister(self, reg):
        """
        Read 32 bit register value.
        @param reg Register in FPGA address space.
        @return Value of register.
        """
        self.__verify32Bit(reg)
        r = c_uint()
        _CeReadRegister(self._handle, reg, byref(r))
        return r.value

    def writeRegister(self, reg, value):
        """
        Write 32 bit register value.
        @param reg Register in FPGA address space.
        @param value Value to write to register.
        """
        self.__verify32Bit(reg)
        self.__verify32Bit(value)
        _CeWriteRegister(self._handle, reg, value)

    def readBlock(self, addr, buf, flags = 0):
        """
        Read data block.
        @param addr Start address in FPGA address space.
        @param buf Space to read to from FPGA address space, must be of type 'array.array'.
        @param flags I/O specific flags (see their individual documentation)
                - Device::FlagConstAddress
        """
        size = buf.itemsize * buf.buffer_info()[1]
        self.__verify32Bit(addr)
        self.__verify32Bit(size)
        _CeReadBlock(self._handle, addr, buf.buffer_info()[0], size, flags)

    def writeBlock(self, addr, buf, flags = 0):
        """
        Write data block.
        @param addr Start address in FPGA address space.
        @param buf Data to write to FPGA address space, must be of type 'array.array'.
        @param flags I/O specific flags (Device::FlagConstAddress).
        """
        size = buf.itemsize * buf.buffer_info()[1]
        self.__verify32Bit(addr)
        self.__verify32Bit(size)
        _CeWriteBlock(self._handle, addr, buf.buffer_info()[0], size, flags)

    def waitForInterrupt(self, timeout):
        """
        Waits for an interrupt, returns if either the interrupt is raised or timeout. Interrupt must be
        enabled using enableInterrupt(). PCI only. Currently not used.
        @param timeout Timeout in ms to wait for interrupt, otherwise the call returns with timeout.
        @return True if interrupt is raised inside timeout timespan, false in case of timeout.
        """
        r = c_uint()
        _CeWaitForInterrupt(self._handle, timeout, byref(r))
        return r.value != 0

    def enableInterrupt(self):
        """
        Enable interrupt catching in underlying API. PCI only. Currently not used.
        If an interrupt is caught, must be recalled again to catch the next.
        """
        _CeEnableInterrupt(self._handle)

    def resetFpga(self):
        """
        Pulse FPGA reset line (the I/O that is chosen to be reset). Useful to bring the FPGA
        in a defined state. Implicitly done after FPGA programming.
        """
        _CeResetFpga(self._handle)

    def programFpgaFromBin(self, fileName):
        """
        Configure FPGA with given design in file. Loads a .bin from as specified by
        fileName and programs the FPGA using this design. Subsequently pulses the reset line.
        @param fileName File which contains design file data.
        """
        _CeProgramFpgaFromBin(self._handle, _toString23(fileName))

    def programFpgaFromMemory(self, buf):
        """
        Configure FPGA with given design in memory. Useful when compiling FPGA designs into
        the executable. UDK3BoardManager creates sources that can be used this way.
        It is preferred to use programFpgaFromMemoryZ().
        @param buf Design, must be of type 'array.array'.
        """
        size = buf.itemsize * buf.buffer_info()[1]
        _CeProgramFpgaFromMemory(self._handle, buf.buffer_info()[0], size)

    def programFpgaFromMemoryZ(self, buf):
        """
        Configure FPGA with given compressed design in memory. Useful when compiling FPGA
        designs into the executable. UDK3BoardManager creates sources that can be used this way.
        Subsequently pulses the reset line.
        @param buf Design pointer, must be of type 'array.array'.
        """
        size = buf.itemsize * buf.buffer_info()[1]
        _CeProgramFpgaFromMemoryZ(self._handle, buf.buffer_info()[0], size)

    def setTimeout(self, timeout):
        """
        Configure timeout until a pending transfer is stopped and defined as failed.
        This timeout is used for all transfers to and from device.
        @param timeout Timespan in milliseconds.
        """
        _CeSetTimeOut(self._handle, timeout)

    def enableBurst(self, enable):
        """
        Enable burst transfers. Currently not used.
        @param enable Enable or disable flag (boolean).
        """
        _CeEnableBurst(self._handle, 1 if enable else 0)

    def getDeviceInfo(self):
        """
        Get general device info.
        """
        return self._info

    def _int1(self, p0, p1, p2, p3, p4 = None):
        """
        Internal use only.
        """
        if (p4 == None):
            _CeInt1(self._handle, p0, p1, p2, p3, None, 0)
        else:
            size = p4.itemsize * p4.buffer_info()[1]
            _CeInt1(self._handle, p0, p1, p2, p3, p4.buffer_info()[0], size)

class EnumeratedDevice:
    """
    Entry returned by enumeration, valid only between two
    enumerations. Call its open() method the get the
    real device handle in form of an instance of type Device.
    """
    def __init__(self, info, eid, erid):
        self._info = info
        self._eid = eid
        self._erid = erid

    def open(self):
        """
        Open this instance, returns object to use for further communication.
        An opened device isn't reported in any subsequent enumeration (system wide), until
        it's closed.
        """
        if (self._erid != _enumRound):
            raise Exception("Invalid enumeration round.")

        handle = c_int()
        _CeOpen(self._eid, byref(handle))

        return Device(self._info, handle.value)

    def getDeviceInfo(self):
        """
        Get general device info.
        """
        return self._info

def getUdkVersion():
    """
    Return full version string of UDK3.
    """
    return _convertToString23(_CeGetUdk3VersionString())

def init():
    """
    The API is not usable before this function (or alternatively initEx()) is called.
    It loads all UDK3 modules from "./". Identical to initEx("./").
    """
    _CeInit()

def initEx(baseDir):
    """
    Alternative to init() but allows specification of the directory where
    '[lib]udk3mod-*' files are located.
    @param baseDir Directory to search for udk modules (if other than ./).
    """
    _CeInitEx(baseDir)

def enumerate(deviceType):
    """
    Search for devices masked by the given device type specifier.
    @param type Filter search by class or type.
    @return List of detected devices. Instances are valid until the next call to enumerate.
    """
    ++_enumRound

    count = c_int()
    _CeEnumerate(deviceType, byref(count))
    r = []

    for i in range(count.value):
        _name = _createCharBuffer23(CE_IF_BUFFER_SIZE)
        bt, dt, vid, pid = c_int(), c_int(), c_int(), c_int()
        _CeEnumerateInfo(i, _name, byref(bt), byref(dt), byref(vid), byref(pid))
        info = DeviceInfo(_convertToString23(_name.value), bt.value, dt.value, vid.value, pid.value)
        r.append(EnumeratedDevice(info, i, _enumRound))

    return r

def deInit():
    """
    Free API resources, closes all devices and unloads all modules. To reuse the API again,
    init() or initEx() must be called again.
    """
    _CeDeInit()

def setLogLevel(level):
    """
    Set logging level (Off = 0, Error = 1, Warning = 2, Debug = 3), default is 2.
    """
    _CeSetLogLevel(level)
